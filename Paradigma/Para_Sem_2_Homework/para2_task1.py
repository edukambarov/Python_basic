# Структурное программирование:
# __
# Трассировка пути в лабиринте:
# __
# Описание: Имеется двумерный массив, представляющий лабиринт,
# где '0' - это проход, а '1' - это стена.
# Начальная и конечная точки заданы. Необходимо определить путь от начальной до конечной точки.
# Почему это структурное программирование:
# Задача может быть решена с помощью последовательных шагов,
# ветвлений (проверка на наличие стены или уже посещенной клетки)
# и циклов (для обработки всех возможных направлений движения).

# Задание:
# Создайте функцию, которая принимает
# двумерный массив (лабиринт) 
# и начальную и конечную точки. 
# Функция должна возвращать путь от начальной до конечной точки
# или сообщение, что путь невозможен.
# Входные данные:
# Двумерный массив размера MxN, где '0' - это проход, а '1' - это стена.
# Координаты начальной и конечной точки.
# Выходные данные:
# Массив координат пути или сообщение об ошибке.


def print_matrix(matrix):
    for row in matrix:
        for element in row:
            print(element, end=' ')
        print()

def find_path(matrix:list, i_start:int, j_start:int, i_finish:int, j_finish:int):
    '''
    Данная функция принимает на вход матрицу-лабиринт с одним входом и выходом
    с заданными координатами согласно условиям задачи.
    По результатам работы фцнкуции мы ожидаем вернуть список <path>,
    состоящий из кортежей с индексами точек,
    образующими путь от входа в лабиринт к выходу из него.
    '''
    path=[]   
    i_min = 0
    i_max = len(matrix)-1
    j_min = 0
    j_max = len(matrix[0])-1
    i = i_start
    j = j_start
    path.append((i_start,j_start)) # добавляем точку входа как первый элемент в списка
    '''
    В этом блоке мы
    1. обрабатываем данные о точке входа,
    2. определяем направление для первого шага.
    Границы для i и j обозначены как i_min(max) и j_min(max).
    Кроме точек входа и выхода значение в соответствующих строках и колонках равно 1.
    '''
    if i_start == i_max: #вверх
        i-=1  
    elif j_start == j_min: #вправо
        j+=1             
    elif i_start == i_min: #вниз
        i+=1                
    elif j_start == j_max: #влево
        j-=1              
    if matrix[i][j] == 0: #дополнительная проверка отсутствия стены 
        path.append((i,j)) #добавляем координаты второй точки в список.
    '''
    1. Используем цикл whilе, чтобы алгоритм внутри выполнялся вплоть до достижения точки выхода.
    2. Внутри цикла анализируем точки вокруг последней из записанных в список и выбираем ту, 
    которая отвечает критериям:
        - отсутствие стены (т.е. равна нулю)
        - ранее не пройдена (т.е пока не записана в результирующий список)
    '''    
    
    while not(i == i_finish and j==j_finish):
        if matrix[i-1][j] == 0 and (i-1,j) not in path:
            i-=1
        elif matrix[i][j+1] == 0 and (i,j+1) not in path:
            j+=1
        elif matrix[i+1][j] == 0 and (i+1,j) not in path:
            i+=1
        elif matrix[i][j-1] == 0 and (i,j-1) not in path:
            j-=1
        else:            
            print('Нет прохода через лабиринт.')
            break        
        path.append((i,j))   
    if i == i_finish and j==j_finish:
        print(f'Проход через лабиринт:\n{path}')
 
m = [
    [1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 1, 0, 1],
    [1, 1, 1, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], 
    [1, 0, 1, 0, 1, 0, 0, 0, 0, 1],    
    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
]

i_start = 10
j_start = 1
i_finish = 0
j_finish = 6

print('Лабиринт m:')
print_matrix(m)
find_path(m, i_start ,j_start, i_finish, j_finish)
          


















     
   




   
      






